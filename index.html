<!DOCTYPE html>
<html>
<head>
    <title>Basic Face Detection</title>
    <meta charset="utf-8">
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1632432234/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1620248257/drawing_utils.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #1a1a1a;
            color: white;
            font-family: Arial, sans-serif;
        }
        #status {
            margin: 20px;
            font-size: 18px;
        }
        #container {
            position: relative;
            width: 640px;
            height: 480px;
        }
        #output_canvas {
            position: absolute;
            left: 0;
            top: 0;
        }
        #video {
            position: absolute;
            left: 0;
            top: 0;
            width: 640px;
            height: 480px;
        }
    </style>
</head>
<body>
    <div id="status">Loading...</div>
    <div id="container">
        <video id="video" playsinline></video>
        <canvas id="output_canvas"></canvas>
    </div>

    <script>
        const videoElement = document.getElementById('video');
        const canvasElement = document.getElementById('output_canvas');
        const statusElement = document.getElementById('status');
        const canvasCtx = canvasElement.getContext('2d');

        function updateStatus(message) {
            statusElement.textContent = message;
            console.log(message);
        }

        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            
            if (results.multiFaceLandmarks) {
                for (const landmarks of results.multiFaceLandmarks) {
                    drawConnectors(canvasCtx, landmarks, FACEMESH_TESSELATION, 
                        { color: '#C0C0C070', lineWidth: 1 });
                    drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_EYE, 
                        { color: '#FF3030', lineWidth: 1 });
                    drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_EYEBROW, 
                        { color: '#FF3030', lineWidth: 1 });
                    drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_EYE, 
                        { color: '#30FF30', lineWidth: 1 });
                    drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_EYEBROW, 
                        { color: '#30FF30', lineWidth: 1 });
                    drawConnectors(canvasCtx, landmarks, FACEMESH_FACE_OVAL, 
                        { color: '#E0E0E0', lineWidth: 1 });
                    drawConnectors(canvasCtx, landmarks, FACEMESH_LIPS, 
                        { color: '#E0E0E0', lineWidth: 1 });
                }
            }
            canvasCtx.restore();
        }

        async function setupCamera() {
            updateStatus('Initializing camera...');
            
            const constraints = {
                video: {
                    width: 640,
                    height: 480,
                    facingMode: 'user'
                }
            };

            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                videoElement.srcObject = stream;
                return new Promise((resolve) => {
                    videoElement.onloadedmetadata = () => {
                        videoElement.play();
                        canvasElement.width = videoElement.videoWidth;
                        canvasElement.height = videoElement.videoHeight;
                        resolve();
                    };
                });
            } catch (error) {
                updateStatus('Error accessing camera: ' + error.message);
                throw error;
            }
        }

        async function initFaceMesh() {
            updateStatus('Initializing FaceMesh...');
            
            const faceMesh = new FaceMesh({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/${file}`;
                }
            });

            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            faceMesh.onResults(onResults);

            try {
                await setupCamera();
                updateStatus('Starting camera feed...');
                
                const camera = new Camera(videoElement, {
                    onFrame: async () => {
                        await faceMesh.send({image: videoElement});
                    },
                    width: 640,
                    height: 480
                });
                
                camera.start();
                updateStatus('Face detection active');
            } catch (error) {
                updateStatus('Error during initialization: ' + error.message);
            }
        }

        // Start the application
        window.onload = initFaceMesh;
    </script>
</body>
</html>
